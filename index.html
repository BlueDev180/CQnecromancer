<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Bonechain (Portrait, v3.1 single-file)</title>
<style>
:root{
  color-scheme:dark;
  --bg:#0f0f11; --ui:#18181b; --grid:#202024; --safeB: env(safe-area-inset-bottom,0px);
}
*{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
html,body{margin:0;background:var(--bg);font-family:-apple-system,system-ui;color:#eee;min-height:100dvh}

header,footer{
  background:var(--ui); color:#eaeaea; display:flex; align-items:center; gap:12px;
  padding:10px 14px; position:relative;
}
header{justify-content:space-between}
.build{color:#7bd7ff;font-size:12px}
.hud span{margin-right:12px}
.btn{background:#2a2a31;color:#fff;border:1px solid #3b3b44;border-radius:8px;padding:8px 12px}

main{display:flex;justify-content:center;padding:8px 10px}
#field{
  width:80vw; height:auto; aspect-ratio:9/16;
  max-height:65dvh; background:#121216; border:1px solid #2a2a31; border-radius:12px;
}

footer{flex-direction:column; align-items:center; padding:10px 12px;
  padding-bottom:calc(12px + var(--safeB)); gap:10px}
.legend{display:flex; gap:8px; flex-wrap:wrap}
.b{display:inline-block; padding:6px 10px; border-radius:8px; font-size:12px}
.b-SK{background:#3a2727}
.b-AR{background:#243a27}
.b-WR{background:#2b2740}
.b-DB{background:#3a2b27}

.bar{
  display:grid;
  grid-template-columns: repeat(6, 1fr); /* 2 rows of 6 */
  gap:8px; width:92vw; max-width:520px;
}
.block{
  background:#23232a; border:2px solid #35353f; border-radius:12px; padding:12px 0;
  text-align:center; font-weight:800; color:#fff; user-select:none;
  box-shadow: inset 0 0 0 2px #0002;
}
.block.sel{outline:3px dashed #fff8}
</style>
</head>
<body>
<header>
  <div class="build">Bonechain v3.1 ‚Ä¢ Portrait</div>
  <div class="hud">
    <span id="wave">Wave 1</span>
    <span id="hp">HP 50</span>
    <span id="souls">Souls 0</span>
  </div>
  <button id="btnPause" class="btn">‚è∏</button>
</header>

<main>
  <canvas id="field" width="405" height="720" aria-label="battlefield"></canvas>
</main>

<footer>
  <div class="legend">
    <span class="b b-SK">üíÄ SKEL</span>
    <span class="b b-AR">üèπ ARCH</span>
    <span class="b b-WR">üëª WRAITH</span>
    <span class="b b-DB">‚ò†Ô∏è BLAST</span>
  </div>
  <div id="blockBar" class="bar" aria-label="skill blocks"></div>
</footer>

<script>
/* Bonechain v3.1 ‚Äì portrait single-file build
   Fixes:
   - Block chain selection is row-aware, centered on tap, up to 3 (BAR_COLS=6).
   - Enemies pin at baseline and damage base on cooldown (no walking off-screen).
*/

const W = 405, H = 720;
const ROWS = 18, COLS = 9;
const cellW = W/COLS, cellH = H/ROWS;
const BASE_Y = H * 0.94;
const BASE_HIT_Y = H * 0.93;

const cvs = document.getElementById('field');
const ctx = cvs.getContext('2d');
const waveEl = document.getElementById('wave');
const hpEl = document.getElementById('hp');
const soulsEl = document.getElementById('souls');
const btnPause = document.getElementById('btnPause');
const bar = document.getElementById('blockBar');

let running = true;
let last = performance.now();

const game = {
  wave: 1,
  necroHP: 50,
  souls: 0,
  units: [],     // {team, kind, x,y, hp,max, atk, rng, cd, tAtk, speed}
  proj: [],      // {x,y, vx,vy, dmg, team, life}
  fx: [],
  spawnGate: 0.4,
  volleyT: 0
};
const TEAMS = {ALLY:'ally', ENEMY:'enemy'};

// ---------- Blocks ----------
const TYPES = ['SK','AR','WR','DB'];
const BAR_COLS = 6;  // *** important for row-aware selection ***
const BAR_SIZE = 12; // 2 rows of 6
let blocks = [];

function refillBlocks(){
  while(blocks.length < BAR_SIZE){
    const k = TYPES[(Math.random()*TYPES.length)|0];
    blocks.push(k);
  }
  renderBar();
}
function renderBar(){
  bar.innerHTML = '';
  blocks.forEach((k,i)=>{
    const d = document.createElement('div');
    d.className = 'block';
    d.dataset.i = i; d.dataset.k = k;
    d.textContent = symbolFor(k);
    d.style.borderColor = colorFor(k);
    d.onclick = onBlockTap;
    bar.appendChild(d);
  });
}
function symbolFor(k){ return k==='SK'?'üíÄ':k==='AR'?'üèπ':k==='WR'?'üëª':'‚ò†Ô∏è'; }
function colorFor(k){
  if (k==='SK') return '#a55';
  if (k==='AR') return '#5a5';
  if (k==='WR') return '#7a67c7';
  return '#b27b55';
}
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

// row-aware, centered-on-tap selection (up to 3)
function onBlockTap(e){
  const i = +e.currentTarget.dataset.i;
  const k = blocks[i];

  // find row bounds
  const rowStart = Math.floor(i / BAR_COLS) * BAR_COLS;
  const rowEnd   = rowStart + BAR_COLS - 1;

  // contiguous run within the row
  let runStart = i, runEnd = i;
  while (runStart - 1 >= rowStart && blocks[runStart - 1] === k) runStart--;
  while (runEnd + 1 <= rowEnd   && blocks[runEnd + 1]   === k) runEnd++;

  const runLen = runEnd - runStart + 1;
  const use = Math.min(3, runLen);

  // pick a window of length `use` that includes the tap, centered if possible
  let sliceStart = i;
  if (use === 3){
    sliceStart = clamp(i - 1, runStart, runEnd - 2);
  } else if (use === 2){
    sliceStart = clamp(i - 1, runStart, runEnd - 1);
  } else {
    sliceStart = i;
  }

  blocks.splice(sliceStart, use);
  refillBlocks();
  cast(k, use);
}

// ---------- Casting ----------
function cast(k, n){
  if (k==='SK'){
    if (n===1) spawnSquad('Skeleton', 1);
    if (n===2) spawnSquad('Skeleton', 2);
    if (n===3) spawnUnit('BoneKnight');
  }else if (k==='AR'){
    if (n===1) spawnSquad('Archer', 1);
    if (n===2) spawnSquad('Archer', 2);
    if (n===3){ spawnSquad('Archer', 2); game.volleyT = 4; fxText(W*0.5,H*0.82,'VOLLEY!'); }
  }else if (k==='WR'){
    if (n===1) spawnSquad('Wraith', 1);
    if (n===2) spawnSquad('Wraith', 2);
    if (n===3) spawnUnit('WraithElite');
  }else if (k==='DB'){
    const r = n===1?54:n===2?82:108;
    const stun = n===3?1.2:0;
    aoe(W*0.5, H*0.33, r, 10 + n*6, stun);
  }
}

// ---------- Units & Stats ----------
function unit(team, kind, hp, atk, rngCells, cd, speed){
  return {team, kind, x:0, y:0, hp, max:hp, atk, rng:rngCells, cd, tAtk:0, speed};
}
function baseUnit(kind){
  switch(kind){
    case 'Skeleton':    return unit(TEAMS.ALLY,'SK', 22, 6, 1, 0.7, 160);
    case 'BoneKnight':  return unit(TEAMS.ALLY,'BK', 48,10, 1, 0.9, 150);
    case 'Archer':      return unit(TEAMS.ALLY,'AR', 16, 7, 4, 1.0, 165);
    case 'Wraith':      return unit(TEAMS.ALLY,'WR', 14, 9, 1, 0.6, 190);
    case 'WraithElite': return unit(TEAMS.ALLY,'WE', 26,14, 1, 0.5, 210);
    case 'Goblin':      return unit(TEAMS.ENEMY,'EG', 16, 5, 1, 0.9, 155);
    case 'Slinger':     return unit(TEAMS.ENEMY,'ES', 12, 6, 4, 1.05,165);
    case 'Brute':       return unit(TEAMS.ENEMY,'EB', 34, 9, 1, 1.0, 135);
  }
  return unit(TEAMS.ENEMY,'EG', 16, 5, 1, 1, 155);
}
function spawnUnit(kind){
  const u = baseUnit(kind);
  if (u.team===TEAMS.ALLY){
    // bottom third band
    u.x = W*0.22 + Math.random()*W*0.56;
    u.y = H*0.78 + (Math.random()*cellH - cellH/2);
  }else{
    // top band
    u.x = W*0.15 + Math.random()*W*0.7;
    u.y = H*0.06 + (Math.random()*cellH*1.5 - cellH*0.75);
  }
  game.units.push(u);
}
function spawnSquad(kind, n){ for(let i=0;i<n;i++) spawnUnit(kind); }

// ---------- Waves ----------
function spawnWave(n){
  let g = 4 + Math.floor(n*1.1);
  let s = Math.floor(n/2);
  let b = Math.floor((n-1)/3);
  for(let i=0;i<g;i++) spawnUnit('Goblin');
  for(let i=0;i<s;i++) spawnUnit('Slinger');
  for(let i=0;i<b;i++) spawnUnit('Brute');
}

// ---------- AOE ----------
function aoe(xc, yc, r, dmg, stun){
  fxRing(xc,yc,r);
  for(const u of game.units){
    if (u.team!==TEAMS.ENEMY || u.hp<=0) continue;
    const dx = u.x - xc, dy = u.y - yc;
    if (Math.hypot(dx,dy) <= r){
      u.hp -= dmg;
      u.tAtk = Math.max(u.tAtk, stun||0);
      fxHit(u.x,u.y);
    }
  }
}

// ---------- Helpers ----------
function nearest(u, team){
  let best=null, bd=1e9;
  for(const v of game.units){
    if (v.team!==team || v.hp<=0) continue;
    const d = Math.abs(v.x-u.x)+Math.abs(v.y-u.y);
    if (d<bd){bd=d; best=v;}
  }
  return best;
}
function nearestPointTarget(p){
  let want = p.team===TEAMS.ALLY ? TEAMS.ENEMY : TEAMS.ALLY;
  let best=null, bd=1e9;
  for(const u of game.units){
    if (u.team!==want || u.hp<=0) continue;
    const d = Math.abs(u.x-p.x)+Math.abs(u.y-p.y);
    if (d<bd){bd=d; best=u;}
  }
  return best;
}

// ---------- Combat / Step ----------
function shoot(u, target, dmg){
  const ang = Math.atan2(target.y-u.y, target.x-u.x);
  game.proj.push({x:u.x, y:u.y, vx:320*Math.cos(ang), vy:320*Math.sin(ang), dmg, team:u.team, life:1.6});
}
function step(dt){
  if (!running) return;

  if (game.spawnGate>0){
    game.spawnGate -= dt;
    if (game.spawnGate<=0) spawnWave(game.wave);
  }
  if (game.volleyT>0) game.volleyT = Math.max(0, game.volleyT - dt);

  for(const u of game.units){
    if (u.hp<=0) continue;

    if (u.team===TEAMS.ALLY){
      const e = nearest(u, TEAMS.ENEMY); if (!e) continue;
      const dx = e.x - u.x, dy = e.y - u.y, dist = Math.hypot(dx,dy);
      const rngPx = u.rng * cellH * 0.9; u.tAtk -= dt;

      if (dist <= rngPx && u.tAtk<=0){
        if (u.rng>1) shoot(u, e, (game.volleyT>0 && u.kind==='AR')? u.atk*1.8 : u.atk);
        else { e.hp -= u.atk; fxHit(e.x,e.y); }
        u.tAtk = u.cd;
      }else{
        const sp = u.speed * dt;
        u.x += sp * Math.sign(dx) * 0.6;
        u.y += sp * Math.sign(dy);
      }
    }else{
      // enemies head down; if no allies nearby and reached baseline, damage base on cooldown
      const a = nearest(u, TEAMS.ALLY);
      const tx = a? a.x : u.x;
      const ty = a? a.y : BASE_Y;
      const dx = tx - u.x, dy = ty - u.y, dist = Math.hypot(dx,dy);
      const rngPx = u.rng * cellH * 0.9; u.tAtk -= dt;

      if (!a && u.y >= BASE_HIT_Y){
        u.y = Math.min(u.y, BASE_Y);
        if (u.tAtk<=0){
          game.necroHP -= u.atk; fxText(W*0.5, H*0.95, '-'+u.atk);
          u.tAtk = u.cd;
        }
      }else if (dist <= rngPx && u.tAtk<=0){
        if (a){
          if (u.rng>1) shoot(u, a, u.atk);
          else { a.hp -= u.atk; fxHit(a.x,a.y); }
        }
        u.tAtk = u.cd;
      }else{
        const sp = u.speed * dt;
        u.x += sp * Math.sign(dx) * 0.4;
        u.y += Math.abs(sp); // bias downward
      }
    }

    // clamp inside field
    u.x = Math.max(8, Math.min(W-8, u.x));
    u.y = Math.max(8, Math.min(H-8, u.y));
  }

  // projectiles
  for(const p of game.proj){
    p.x += p.vx*dt; p.y += p.vy*dt; p.life -= dt;
    if (p.life<=0) p.dead = true;
    const tgt = nearestPointTarget(p);
    if (tgt && Math.hypot(tgt.x-p.x,tgt.y-p.y) < 8){
      tgt.hp -= p.dmg; fxHit(tgt.x,tgt.y); p.dead = true;
    }
  }
  game.proj = game.proj.filter(p=>!p.dead);

  // cleanup
  for(const u of game.units) if (u.hp<=0 || u.y > H+24) u.dead = true;
  game.units = game.units.filter(u=>!u.dead);

  // wave clear / defeat
  const enemiesLeft = game.units.some(u=>u.team===TEAMS.ENEMY);
  if (!enemiesLeft && game.spawnGate<=0){
    game.souls += 2 + Math.floor(game.wave/3);
    soulsEl.textContent = `Souls ${game.souls}`;
    fxText(W*0.5, H*0.08, `WAVE ${game.wave} CLEAR!`);
    game.wave++;
    waveEl.textContent = `Wave ${game.wave}`;
    game.spawnGate = 0.8;

    if (Math.random()<0.7) blocks.unshift('SK');
    if (Math.random()<0.5) blocks.unshift('AR');
    while(blocks.length>BAR_SIZE) blocks.pop();
    renderBar();
  }
  if (game.necroHP<=0){
    running=false;
    fxText(W*0.5, H*0.5, 'DEFEAT');
  }
  hpEl.textContent = `HP ${Math.max(0,game.necroHP)}`;
}

// ---------- FX & Render ----------
function fxHit(x,y){ game.fx.push({x,y,t:0.15,type:'hit'}); }
function fxRing(x,y,r){ game.fx.push({x,y,t:0.4, r, type:'ring'}); }
function fxText(x,y,txt){ game.fx.push({x,y,t:1.0, text:txt, type:'text', yo:0}); }

function draw(){
  ctx.clearRect(0,0,W,H);

  // grid
  ctx.strokeStyle = '#1e1e24';
  for(let r=1;r<ROWS;r++){ ctx.beginPath(); ctx.moveTo(0,r*cellH); ctx.lineTo(W,r*cellH); ctx.stroke(); }
  for(let c=1;c<COLS;c++){ ctx.beginPath(); ctx.moveTo(c*cellW,0); ctx.lineTo(c*cellW,H); ctx.stroke(); }

  // baseline
  ctx.fillStyle = '#24242c';
  ctx.fillRect(W*0.05, BASE_Y, W*0.9, 4);

  // units
  for(const u of game.units){
    const ally = u.team===TEAMS.ALLY;
    ctx.fillStyle = ally ? '#5ed892' : '#e06a6a';
    if (u.kind==='AR') ctx.fillStyle = '#7ed0ff';
    if (u.kind==='WR'||u.kind==='WE') ctx.fillStyle = '#b69aff';
    if (u.kind==='BK') ctx.fillStyle = '#e0c078';
    ctx.fillRect(u.x-8,u.y-8,16,16);

    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(u.x-9,u.y+10,18,3.5);
    ctx.fillStyle = '#7cf470';
    ctx.fillRect(u.x-9,u.y+10, 18*(u.hp/u.max),3.5);
  }

  // projectiles
  ctx.fillStyle = '#fff';
  for(const p of game.proj){ ctx.beginPath(); ctx.arc(p.x,p.y,2.8,0,Math.PI*2); ctx.fill(); }

  // fx
  for(const f of game.fx){
    f.t -= 1/60;
    if (f.type==='hit'){
      ctx.strokeStyle = '#fff8';
      ctx.strokeRect(f.x-10,f.y-10,20,20);
    }else if(f.type==='ring'){
      ctx.strokeStyle = '#ffdd77aa';
      ctx.beginPath(); ctx.arc(f.x,f.y, f.r*(1-f.t/0.4), 0, Math.PI*2); ctx.stroke();
    }else if(f.type==='text'){
      f.yo -= 0.7;
      ctx.fillStyle = '#ffd45a';
      ctx.font = 'bold 16px system-ui';
      ctx.textAlign='center';
      ctx.fillText(f.text, f.x, f.y + f.yo);
    }
  }
  game.fx = game.fx.filter(f=>f.t>0);
}

// ---------- Loop / UI ----------
function loop(now){
  const dt = Math.min((now-last)/1000, 1/30); last = now;
  if (running) step(dt);
  draw();
  requestAnimationFrame(loop);
}
btnPause.onclick = ()=>{ running = !running; btnPause.textContent = running?'‚è∏':'‚ñ∂Ô∏è'; };

refillBlocks();
requestAnimationFrame(loop);
</script>
</body>
</html>
